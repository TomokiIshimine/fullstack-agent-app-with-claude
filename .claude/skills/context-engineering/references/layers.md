# 5層コンテキストモデル 詳細定義

## 目次

1. [Layer 1: CLAUDE.md — プロジェクトの共通基盤](#layer-1-claudemd)
2. [Layer 2: サブエージェント — 役割ごとの判断主体](#layer-2-サブエージェント)
3. [Layer 3: スキル — 再利用可能な技術的能力](#layer-3-スキル)
4. [Layer 4: スラッシュコマンド — 軽量なタスクオーケストレーター](#layer-4-スラッシュコマンド)
5. [Layer 5: ドキュメント — コード探索のための地図](#layer-5-ドキュメント)

---

## Layer 1: CLAUDE.md

### 役割

すべての状況において参照される最上位のコンテキスト。プロジェクトの共通基盤であり、常に薄く保つ。

### 含めるべき内容（優先度順）

1. **プロジェクトの目的** — なぜこのプロジェクトが存在するのか
2. **開発における設計原則** — シンプルさ優先、DRY、テスト駆動など
3. **技術スタック・規約の概要** — 詳細は各層に委ね、ここには簡潔な概要のみ
4. **ディレクトリ構成** — 主要な2階層までを記載
5. **ドキュメントへのパス** — 各設計ドキュメントの所在を明示

### スコープの判断基準

- 全役割に共通して必要な情報 → CLAUDE.mdに含める
- 特定の役割だけが必要とする情報 → サブエージェント側に置く
- 複数の役割に関わるが全役割ではない情報 → CLAUDE.mdには概要のみ、詳細は各役割側

### ナビゲーション機能

CLAUDE.mdはディレクトリ構成とドキュメントパスを通じて、プロジェクト内のコードやドキュメントへのエントリーポイントとしても機能する。AIがプロジェクト全体を効率よく探索するための起点となる。

### アンチパターン

- 特定のエージェントだけが使う詳細な手順をCLAUDE.mdに書く
- すべての技術規約をCLAUDE.mdに詰め込む
- CLAUDE.mdが100行を大幅に超える

---

## Layer 2: サブエージェント

### 役割

プロジェクト内の各役割を定義する判断主体。コーダー、レビュアー、デプロイ担当、プロジェクト管理者などがこれにあたる。

### 定義の核となる要素

- **責務（What）** — その役割が何をすべきか
- **判断基準（Why）** — 迷った時にどう判断するか

エージェントは「What」と「Why」の層。具体的な手法（How）はスキルに委ねる。

### 設計の指針

- エージェントは役割に応じて必要なスキルを「名指しで」使用する
- エージェントは役割に応じて必要なドキュメントを参照する
- 1エージェント = 1役割の原則を守る。複数の責務を1つのエージェントに混ぜない

### ファイル配置

```
.claude/agents/
├── coder.md         # コーディング担当
├── reviewer.md      # コードレビュー担当
├── deployer.md      # デプロイ担当
└── pm.md            # プロジェクト管理
```

### テンプレート

```markdown
# [エージェント名]

## 責務
[この役割が何をすべきかを簡潔に記述]

## 判断基準
[迷った時の判断指針をリストアップ]

## 使用するスキル
- [スキル名1] — [どの場面で使うか]
- [スキル名2] — [どの場面で使うか]

## 参照するドキュメント
- [ドキュメントパス1] — [何を確認するために読むか]
- [ドキュメントパス2] — [何を確認するために読むか]
```

### アンチパターン

- 具体的なコーディング手法（How）をエージェント定義に書く → スキルに分離すべき
- 1つのエージェントに複数の役割を混ぜる
- エージェントからドキュメントを直接更新する手順を書く（エージェントはドキュメントの読み取りのみ）

---

## Layer 3: スキル

### 役割

「どうやるか（How）」の具体的な手法と注意点を定義する。再利用可能な技術的能力。

### 例

- フロントエンドのコーディング手法と注意点
- バックエンドのコーディング手法と注意点
- テスト作成のベストプラクティス
- データベースマイグレーションの手順

### 重要な特性

- スキルはエージェントに従属しない。独立した共有リソースとして存在する
- 複数のエージェントから共有して使用される（例：フロントエンドスキルはコーダーにもレビュアーにも使われ得る）
- エージェントからスキルが「名指しで」使用される
- **スキルからドキュメントへの直接参照はしない**。ドキュメント参照は常にエージェント経由で行う

### ファイル配置

```
.claude/skills/
├── frontend-coding.md
├── backend-coding.md
├── testing.md
└── db-migration.md
```

### テンプレート

```markdown
# [スキル名]

## 概要
[このスキルが提供する能力を1-2行で]

## 手法
[具体的なコーディングパターン、手順、注意点]

## 注意点
[よくある落とし穴、避けるべきパターン]

## 例
[具体的な入出力の例]
```

### アンチパターン

- スキル内で特定のエージェントの判断基準を記述する → エージェント側に置くべき
- スキルからドキュメントを直接参照する → エージェント経由にすべき
- 1つのスキルに複数の独立した技術領域を混ぜる

---

## Layer 4: スラッシュコマンド

### 役割

定型タスクの実行を指揮する軽量なオーケストレーター。

### 機能

- 呼び出すエージェントやスキルの順序を定義する
- 単一エージェントを呼ぶ場合もあれば、複数エージェントを組み合わせる場合もある
- タスクによってはスキルを直接呼び出すこともある

### 重要な特性

- 固定的なものではなく、プロジェクトの進行とともに気軽に追加・増殖していく軽量なタスクテンプレートである
- 機能実装、リファクタリングなどの定型タスクごとに定義される

### ファイル配置

```
.claude/commands/
├── implement.md     # 機能実装
├── refactor.md      # リファクタリング
├── review.md        # コードレビュー
├── fix-bug.md       # バグ修正
└── deploy.md        # デプロイ
```

### テンプレート

```markdown
# /[コマンド名]

## 概要
[このコマンドが何をするか1行で]

## 実行フロー

1. [ステップ1: エージェントまたはスキルの呼び出し]
2. [ステップ2: 次のエージェントまたはスキルの呼び出し]
3. ...

## 入力
[ユーザーから受け取るパラメータ]

## 完了条件
[このコマンドが完了したと判断する基準]
```

### 設計のコツ

- スラッシュコマンドは「薄い」オーケストレーターであるべき。ロジックはエージェントやスキルに置く
- 新しい定型タスクが見つかったら気軽にコマンドを追加する。完璧を求めない
- 複雑なタスクは複数のエージェントを順番に呼び出すコマンドとして定義する

### アンチパターン

- スラッシュコマンド内に具体的な実装ロジックを書く → スキルに分離すべき
- スラッシュコマンド内で判断基準を定義する → エージェントに分離すべき
- スラッシュコマンドを過度に抽象化して汎用にしすぎる

---

## Layer 5: ドキュメント

### 役割

コード探索のための地図。Claude Code固有の機能ではなく、プロジェクト内の基本設計書にあたる。

### 位置づけの思想

- **コードが真実のドキュメント** — ドキュメントはコードの代替ではない
- **ドキュメントは「地図」** — コード全体を毎回読むコストを下げ、全体像を把握した上で最適なコードを探索するためのガイド
- **更新され続けることが前提** — マイルストーンや機能実装完了時に定期的にコードに追従して更新する

### 少なく保つ理由

- ドキュメントが増えるとコードとの乖離が起きやすくメンテナンスコストが高い
- 「コードが真実」であるため、ドキュメントはあくまで補助

### ドキュメント化の判断基準

以下のいずれかに該当する情報をドキュメントとして管理する:

- **全体の地図としての役割を持つ情報** — コード全体を毎回読むことなく全体像を把握し、最適なコードを探索するために必要な情報
- **頻繁に更新される情報** — プロジェクトの進行に伴い変化し続ける情報は、コードに散在させるよりドキュメントとして一元管理する方がメンテナンスしやすい

### 含めるべきドキュメント一覧

詳細は `references/documents-guide.md` を参照。

1. 機能一覧
2. 画面一覧
3. データベース設計（テーブル定義）
4. アーキテクチャ設計
5. 環境構築手順書
6. E2Eテスト一覧

### アンチパターン

- コードのコメントで十分な情報をドキュメントに二重記載する
- ドキュメントを更新せずに放置してコードとの乖離を起こす
- 補助であるドキュメントを「正」として扱い、コードと矛盾する場合にドキュメントを優先する
